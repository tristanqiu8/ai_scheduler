# Preemptive Hardware Model Design

## Goals
- 允许高优先级任务在 NPU/DSP 资源上抢占低优先级任务。
- 为每次抢占和恢复引入固定的硬件开销（如 0.1 ms 量级）。
- 确保调度逻辑、结果 JSON、Chrome Trace 等产物对抢占行为的一致呈现。

## 关键挑战
1. **调度决策**：何时允许抢占，如何避免频繁抢占导致的反复上下文切换。
2. **执行状态保存**：需要记录子段的剩余工作量，以便恢复时继续执行。
3. **开销注入**：扣除抢占/恢复成本并反映在时序统计中。
4. **可观测性**：让调试工具和最终结果可以看见抢占发生及其影响。

## 架构设计

### 1. 抢占策略层
- 在 `ScheduleExecutor`（或独立策略模块）增加抢占判断：
  - 当高优先级子段 ready 时，检查目标资源上是否运行低优先级段。
  - 支持优先级阈值、任务白名单或资源类型限制。
  - 记录每次抢占决策，便于验证和回放。

### 2. 资源队列扩展
- `ResourceQueue` 需要保存当前执行子段的进度（已执行时长、剩余时长）。
- 发生抢占时：
  1. 结束当前 slice，记录到 tracer。
  2. 添加 `preempt_cost_ms`（高优先级任务启动前的硬件上下文切换）。
  3. 将被抢占子段重新入队，保留剩余工作量。
  4. 在恢复时再加 `resume_cost_ms` 并继续执行。
- 可选：为被抢占子段设置单独的恢复队列或优先级提升策略。

### 3. 执行状态管理
- `SubSegment` 或包装对象需增加 `executed_duration` 字段，用于恢复。
- 若模型不支持任意断点续跑，可在建模阶段对长段拆分为细粒度子段。
- 对“不可抢占”的段提供标志位，策略层可直接跳过。

### 4. 开销建模
- 新的优化配置字段：
  - `enable_preemption`
  - `preempt_cost_ms`
  - `resume_cost_ms`
  - 可选 `preempt_min_priority_delta`、每资源覆盖等。
- 每次抢占/恢复都要显式扣费，并计入该任务实例的总延迟。

## 遥测与可视化
- `ScheduleTracer` 增加事件类型：`TASK_PREEMPT`、`TASK_RESUME`，在 metadata 中注明来源任务、目标任务、开销、剩余时长等。
- Chrome Trace：
  - 资源轨道上插入 instant 或短 `X` 事件标记抢占点。
  - TaskLatency 轨道的总时延包含抢占造成的等待时间，并在 `args` 中列出 `preempt_count`、`preempt_overhead_ms` 等字段。
- 结果 JSON (`latency_details`)：为每个实例增加 `preempt_count`、`preempt_overhead_ms`、`was_preempted`。

## 配置 & 文档
- 更新 docs/JSON 接口说明和 README，描述新配置项及默认值。
- 在示例配置中展示如何开启抢占、如何调整开销。
- 若需要兼容旧版本，可默认关闭抢占。

## 测试建议
- **单元测试**：
  - 构造高/低优先级任务，验证抢占触发次数。
  - 检查被抢占段的剩余时间是否复原执行。
- **集成测试**：
  - 比较开启/关闭抢占的延迟差异，验证开销累积正确。
  - 确保 `launch_strategy = sync` 时抢占逻辑被禁用。
- **可视化验证**：
  - 在 Chrome Trace 中确认抢占标记、任务时长与 JSON 匹配。
  - 检查 result JSON 中的 `preempt_overhead_ms` 是否与配置一致。

## 后续演进方向
- 动态调整抢占成本（依据段长度、资源类型）。
- 引入“抢占提示”模式仅记录潜在抢占，不实际执行，用作调试。
- 探索多级优先级资源隔离策略，减少抢占对整体吞吐的冲击。
